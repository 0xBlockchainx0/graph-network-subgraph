"""Graph Network global parameters"""
type GraphNetwork @entity {
  "id = 1"
  id: ID!
  "Contract address"
  graphToken: Bytes!
  "Contract address"
  epochManager: Bytes!
  "Contract address"
  curation: Bytes!
  "Contract address"
  staking: Bytes!
  "Contract address"
  disputeManager: Bytes!
  "Contract address"
  gns: Bytes!
  "Contract address"
  serviceRegistry: Bytes!
  "Set to true if the protocol is paused"
  paused: Boolean!

  # Staking global variables
  "Percentage of fees going to curators"
  curationPercentage: BigInt!
  "Capacity of staked delegation tokens to own stake"
  delegationCapacity: Int!
  "Period to wait before fees can be claimed in rebate pool"
  channelDisputeEpochs: BigInt!
  "Period to wait before delegators can settle"
  maxAllocationEpochs: BigInt!
  "Time in blocks needed to wait to unstake"
  thawingPeriod: BigInt!
  "All addresses that have slashing privileges"
  slashers: [Bytes!]
  "Minimum time an Indexer must use for resetting their Delegation parameters"
  minDelegationParameterCooldown: Int!
  "The number of indexing rewards handed out per epoch"
  indexingRewardsPerEpoch: Int!
  "The issuance rate that GRT is minted at to support Indexers of the protocol"
  networkGRTIssuance: Int!
  "The total amount of GRT staked in the staking contract"
  totalGRTStaked: BigInt!

  # Curation global variables
  "Default reserve ratio for all subgraphs"
  defaultReserveRatio: BigInt!
  "Minimum amount of tokens needed to start curating"
  minimumCurationSignal: BigInt!
  "The total amount of GRT staked in the Curation contract"
  totalGRTSignaled: BigInt!

  # Graph Token global variables
  "Graph Token supply"
  totalSupply: BigInt!

  # Epoch Manager global variables
  "Epoch Length in blocks"
  epochLength: Int!
  "Epoch that was last run"
  lastRunEpoch: Int!
  "Epoch when epoch length was last updated"
  lastLengthUpdateEpoch: Int!
  "Block when epoch length was last updated"
  lastLengthUpdateBlock: Int!

  # Dispute Manager global variables
  "Address with permission to verify or reject disputes"
  arbitrator: Bytes!
  "Minimum deposit to create a dispute"
  minimumDisputeDeposit: BigInt!
  "Reward to Fisherman on successful disputes"
  fishermanRewardPercentage: BigInt!
  "Penalty to Indexer on successful disputes"
  slashingPercentage: BigInt!
}

"""Account type is a user in the front end which could be doing any actions"""
type Account @entity {
  # From GNS
  "Eth address"
  id: ID!
  "IPFS hash with account metadata details"
  metadataHash: Bytes!
  "Name of the account"
  name: String!
  "Named subgraphs this account owns"
  namedSubgraphs: [NamedSubgraph!]!

  # From Graph Token
  "Graph token balance"
  balance: BigInt!

  # From Staking and Curating and Delegating
  "Subgraphs this account curates"
  curator: Curator
  "Subgraphs this account indexes"
  indexer: Indexer
  "Subgraphs this account has delegated to"
  delegator: Delegator
}

"""All the information related the name that is in the GNS"""
type NamedSubgraph @entity {
  # From GNS
  "Hash of the domain name"
  id: ID!
  "System used for naming"
  nameSystem: String
  "Name of the subgraph"
  name: String!
  "Owner of this subgraph"
  owner: Account!
  "Current version"
  currentVersion: SubgraphVersion
  "Past versions"
  pastVersions: [SubgraphVersion!]

  # TODO - add these later in the event that this is implemented :
  # https://www.notion.so/thegraph/Graph-Name-Service-Signaling-30e72e7f1b3c46a4a6b224155e5a6612#a379698b83c241208b6929a1788bcf4e 

  # Aggregate data
  # "Total inflation rewards earned all time by this named subgraph"
  # totalSubgraphIndexingRewards: BigInt!
  # "Total query fees earned by this named subgraph"
  # totalQueryFeesCollected: BigInt! 
  # "Total stake of all indexers on all subgraph versions"
  # totalStake: BigInt!
  # "Total signal of all curators on all subgraph versions"
  # totalSignal: BigInt!
}

"""Contains all the version metadata"""
type SubgraphVersion @entity {
  "Concatenation of named subgraph, subgraph, and version ID"
  id: ID!
  "Named subgraph of this version"
  namedSubgraph: NamedSubgraph!
  "Subgraph of this version"
  subgraph: Subgraph!
  "Version number"
  version: Int!

  # Metadata from IPFS linked in GNS
  "Subgraph metadata"
  metadataHash: Bytes!
  "Short description of the subgraph"
  description: String!
  "Image in string format"
  image: String!
  "Subtitle for display"
  subtitle: String!
  "Display name for subgraph"
  displayName: String!
  "Location of the code for this project"
  repoAddress: String!
  "Project's website"
  websiteURL: String!
  "Network that the subgraph is indexing"
  network: String!
  "Creation timestamp"
  createdAt: Int!
  "Deploy timestamp"
  updatedAt: Int!
}

"""The immutable subgraph defined by a subgraph manifest, that Indexers stake on and Curators signal on"""
type Subgraph @entity {
  "Subgraph ID"
  id: ID!
  "The versions this subgraph relates to"
  versions: [SubgraphVersion!] @derivedFrom(field: "subgraph")
  "Creation timestamp"
  createdAt: Int!

  # From Staking
  "Total stake of all indexers on this Subgraph"
  totalStake: BigInt!
  "Indexers of this subgraph"
  indexers: [Channel!] @derivedFrom(field: "subgraph")
  "Total fees accrued all time by this subgraph version"
  totalSubraphIndexingRewards: BigInt!
  "Total query fees earned by this subgraph version"
  totalQueryFeesCollected: BigInt!

  # From Curation
  "Total signal of all curators"
  totalSignaledGRT: BigInt!
  "Total curation signal on this subgraph version"
  totalSignalMinted: BigInt!

  "Curators of this subgraph version"
  curators: [Signal!] @derivedFrom(field: "subgraph")
  "Bonding curve reserve ratio"
  reserveRatio: BigInt!

  # From Subgraph Manifest
  # dataSources: [DataSource!] # TODO - add a ! when we have the ability to parse data sources
}

"""Data source obtained from the subgraph manifest"""
type DataSource @entity {
  "Unique identifier of the data source. Such as contract address"
  id: ID!
  "Data source name in the manifest"
  name: String!
  "Network "
  network: String!  
}

"""Indexer represents metadata of the indexer all of its stake and delegator stake"""
type Indexer @entity {
  "Eth address of Indexer"
  id: ID!
  "Time this indexer was created"
  createdAt: Int!
  "Account of this indexer"
  account: Account!
  "Service registry URL string"
  urlString: String
  "Geohash of the indexer"
  geoHash: String
  "Total tokens staked"
  stakedTokens: BigInt!
  "Total tokens allocated"
  tokensAllocated: BigInt!
  "Total tokens locked"
  tokensLocked: BigInt!
  "Time when Indexers tokens unlock"
  tokensLockedUntil: Int!
  "Channels this indexer is currently staked on"
  channels: [Channel!] @derivedFrom(field: "indexer")

  # Delegator fields
  "Delegators to this Indexer"
  delegators: [DelegatedStake!] @derivedFrom(field: "indexer")
  "Total tokens delegated to the indexer"
  tokensDelegated: BigInt!
  "Total tokens available to be delegated"
  tokenCapacity: BigInt!
  "The percent the Indexer agrees to share with delegators"
  indexingRewardCut: Int!
  "The percent of query rebate rewards the Indexer agrees to share with delegators"
  queryFeeCut: Int!
  "Time delegator decides to wait for changing of their parameters"
  delegatorParameterCooldown: Int!
  "Count of how many times this indexer has been forced to settle"
  forcedSettlements: Int!
}

"""Allocation represents the continuous stake of an Indexer on a Subgraph, which is the accumulation of Channels between an indexer and a subgraph"""
type Allocation @entity {
  "Indexer ID concatenated with the Subgraph ID"
  id: ID!
  "Indexer of this Allocation"
  indexer: Indexer!
  "Subgraph of this Allocation"
  subgraph: Subgraph!
  "Active Channel. Null if this Indexer is no longer indexing this subgraph"
  activeChannel: Channel
  "Past channels and active channel for this Allocation"
  channels: [Channel!] @derivedFrom(field: "allocation")
}

"""State channel allocation representing Indexer-Subgraph stake"""
type Channel @entity {
  "Channel Address"
  id: ID!
  "Indexer of this channel"
  indexer: Indexer!
  "Subgraph that is being staked on with an open channel"
  subgraph: Subgraph!
  "Allocation this channel is a part of"
  allocation: Allocation!
  "Tokens associated with the channel"
  tokensAllocated: BigInt!
  "Epoch this channel was created"
  createdAtEpoch: Int!
  "Fees this channel collected upon closing, excluding curator reward"
  feesCollected: BigInt!
  "Curator rewards deposited to the curating bonding curve"
  curatorReward: BigInt!
  "Epoch number of the Pool it was settled in"
  settled: Pool
  "Whether or not the channel has been claimed"
  claimed: Boolean!
}

"""Global pool of query fees for settled state channels after Curation rewards have been removed. One pool per epoch"""
type Pool @entity {
  "Epoch number of the pool"
  id: ID!
  "Total fees earned in this epoch"
  fees: BigInt!
  "Total allocation settled in this epoch"
  allocation: BigInt!
  "Total allocation claimed in this epoch"
  allocationClaimed: BigInt!
  "Total rewards deposited to all curator bonding curves during the epoch"
  curatorReward: BigInt!
  "Channels that were settled during this epoch"
  settled: [Channel!] @derivedFrom(field: "settled")
}

"""All data regarding an Indexing Reward"""
type IndexingReward @entity {
  "Reward ID"
  id: ID!
  "Minted GRT in this epoch"
  mintedGRT: BigInt!
  "Epoch the reward was handed out"
  epoch: Int!
  "Total allocation settled in this epoch"
  allocation: BigInt!
  "Subgraph that won durning this epoch"
  subgraph: Subgraph!
  "Winning Indexer"
  indexer: Indexer!
  "True if reward has been claimed"
  claimed: Boolean!  
}

"""Delegator with all their stakes"""
type Delegator @entity {
  "Delegator address"
  id: ID!
  "Stakes of this delegator"
  stakes: [DelegatedStake!] @derivedFrom(field: "delegator")
}

"""Delegator stake for a single Indexer"""
type DelegatedStake @entity {
  "Concatenation of Delegator address and Indexer address"
  id: ID!
  "Index the stake is delegated to"
  indexer: Indexer!
  "Delegator"
  delegator: Delegator!
  "Amount delegated"
  stake: BigInt!
}

"""Curator with all their signals"""
type Curator @entity {
  "Eth address of the Curator"
  id: ID!
  "Time this curator was created"
  createdAt: Int!
  "Account of this curator"
  account: Account!
  "Total minted signal this curator has on all subgraphs"
  totalSignal: BigInt!
  "Total GRT signaled on all the subgraphs"
  totalSignaledGRT: BigInt!
  "Total GRT redeemed on all the subgraphs"
  totalRedeemedGRT: BigInt!
  "Total fees earned from being a curator" # TODO - might remove, this is hard to calculate
  feesEarned: BigInt!
  "Subgraphs the curator is curating"
  signals: [Signal!] @derivedFrom(field: "curator")

}

"""Curator signal for a single Subgraph"""
type Signal @entity {
  "Eth address + subgraph ID"
  id: ID!
  "Eth address of the curator"
  curator: Curator!
  "Subgraph being signaled"
  subgraph: Subgraph!
  "Cumulative number of tokens the curator has signaled"
  tokensSignaled: BigInt!
  "Cumulative number of tokens the curator has redeemed"
  tokensRedeemed: BigInt!
  "Signal that the curator has from signaling their GRT"
  signal: BigInt!
}

"""Dispute of a query. Includes both normal and attestation Disputes"""
type Dispute @entity {
  "Dispute ID"
  id: ID!
  "Subgraph of the dispute"
  subgraph: Subgraph!
  "Indexer disputed. If an attestation dispute there will be 2 indexers"
  indexers: [Indexer!]!
  "Fisherman address"
  fisherman: Bytes!
  "Fisherman deposit"
  deposit: BigInt!
  "Attestation disputed. If an attestation dispute there will be 2 attestation"
  attestation: [Attestation]!
  "Time dispute was created"
  createdAt: Int!
  "Result of either type of dispute"
  result: DisputeResult!
  "Tokens slashed"
  tokensSlashed: BigInt!
  "Tokens rewarded"
  tokensRewarded: BigInt!  
}

"""Attestation of a dispute"""
type Attestation @entity {
  "Concatenation of the requestCID and responseCID"
  id: ID!
  "Subgraph of the subgraph being disputed"
  subgraph: Subgraph!
  "RequestCID"
  requestCID: String!
  "ResponseCID"
  responseCID: String!
  "Gas used by the attested query"
  gasUsed: BigInt!
  "Bytes of attested query"
  responseNumBytes: BigInt!
  "V of the indexers signature"
  v: Int!
  "R of the indexers signature"
  r: Bytes!
  "S of the indexers signature"
  s: Bytes!
}

enum DisputeResult {
  Undecided
  Accepted
  Rejected
  Draw
  Indexer1Correct
  Indexer2Correct
}
