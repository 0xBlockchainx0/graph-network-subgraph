type Account @entity {
  # From GNS.sol
  id: ID!
  metadataHash: Bytes

  # From GraphToken.sol
  balance: BigInt
  # approvals: [Bytes!]!
  # allowances: [BigInt!]!
  curating: [Curator!] @derivedFrom(field: "user")
  indexing: [IndexNode!] @derivedFrom(field: "user")
}

type Domain @entity {
  id: ID! # Domain Hash
  name: String # Domain name, can be a tld or subdomain
  owner: Bytes # Domain owner
  parentDomain: Bytes # If it is a tld, parent domain is null
  subgraphID: Bytes # If it is not set yet, it is null
  metadataHash: Bytes
}

type Subgraph @entity {
  id: ID! # Domain Hash
  name: String # Domain name, can be a tld or subdomain
  owner: Bytes # Domain owner
  parent: Subgraph # If it is a tld, parent domain is null
  children: [Subgraph!] # Child subgraphs
  versions: [SubgraphVersion!]
  curators: [Curator!]
  type: SubgraphType
  metadataHash: Bytes

  # Subgraph metadata
  displayName: String
  subtitle: String
  image: String
  description: String
  githubUrl: String

  # from staking TODO - add back the !'s for these 5 fields
  reserveRatio: BigInt
  totalCurationStake: BigInt
  totalCurationShares: BigInt
  totalIndexingStake: BigInt
  totalIndexers: Int
}

type SubgraphVersion @entity {
  id: ID! # IPFS hash of the subgraph manifest
  subgraph: Subgraph!
  schema: String!

  # from staking
  totalCurationStake: BigInt
  totalIndexingStake: BigInt
}

type GraphToken @entity {
  id: ID! # Just the value 1
  total: BigInt!
}

type IndexNode @entity {
  id: ID! # eth address of index node + subgraph ID
  user: Account! # Eth addrress - for searching and filtering
  subgraphID: Bytes! # SubgraphID - for searching and filtering
  tokensStaked: BigInt! # If this is 0, it means they have logged out
  # By knowing the thawing time, we can derive the time they can withdraw
  logoutStartTime: Int! # frrom IndexingNodeLogout

  # feesAccrued: BigInt # not clear how this will work yet, in the smart contract
}

# we probably need shares, unreralized gains, fees accrued
# unrealized is derived from the total share of the pool, and the users shares, minus what they have deposited , and fees might be involved here

type Curator @entity {
  id: ID! # eth address of curator + subgraph ID
  user: Account! # Eth address - for searching and filtering
  subgraphID: Bytes! # SubgraphID - for searching and filtering
  tokensStaked: BigInt!
  shares: BigInt!
}

# Not in use

#type Dispute @entity {
#    id: ID! # dispute ID
#    subgraphID: Bytes!
#    indexingNode: Bytes!
#    fisherman: Bytes!
#    attestation: Bytes!
#    status: DisputeStatus!
#}
#
#enum DisputeStatus {
#    Created,
#    Accepted,
#    Rejected
#}

# might have to add specifics here of each type, but i think i can probably
# actually pass on that. this info might be enough
type Transactions @entity {
  id: ID! # tx hash (plus log index)
  timestamp: Int!
  block: Int!
  type: TransactionType!
}

# others to probably add GNS - transfer GNS ownership, delete subgraph, account metadata and subgraph metadata changed
# Staking - curatorBeginLogout, Disputes (not included yet), distribute channel fees
enum TransactionType {
  CurateStake
  CurateUnstake
  IndexingStake
  IndexingUnstake
  RegisterGNS
  UpdateGNS
  DeploySubgraphToGNS
}

enum SubgraphType {
  commons
  owned
}
