type Subgraph @entity {
  #### From gns contract ####
  "Hash of the domain name"
  id: ID!
  "Domain name, could be tld or subdomain"
  name: String
  "Eth address"
  owner: Bytes
  "Parent subgraph. If it is a tld, this is null"
  parent: Subgraph
  "Children Subgraphs"
  children: [Subgraph!]! @derivedFrom(field: "parent")
  "Versions of this subgraph. Last version in array is current"
  versions: [SubgraphVersion!]
  "Subgraph metadata"
  metadataHash: Bytes

  #### Metadata taken from IPFS, also from GNS ####
  "Short description of the subgraph"
  description: String
  "Common subgraph or owned by a user"
  type: SubgraphType
  "Image in string format"
  image: String
  "Subtitle for display"
  subtitle: String
  "Display name for subgraph"
  displayName: String
  "Github url of the subgraph repo"
  githubURL: String
  "Project's website"
  websiteURL: String
  "Creation timestamp"
  createdAt: Int
  "Deploy timestamp"
  updatedAt: Int

  #### From staking contract ####
#  "Curators of this subgraph"
#  curatorInfo: [CuratorInfo!]
#  "Indexers of this subgraph"
#  indexerInfo: [IndexerInfo!]
#  "Bonding curve reserve ratio"
#  reserveRatio: BigInt
#  "Total curation stake on this subgraph"
#  totalCurationStake: BigInt
#  "Total curation shares on this subgraph"
#  totalCurationShares: BigInt
#  "Total indexing stake on this subgraph"
#  totalIndexingStake: BigInt
}

enum SubgraphType {
  Commons
  Owned
}

type SubgraphVersion @entity {
  "Subgraph ID"
  id: ID!
  "The subgraph this version is related to"
  subgraph: Subgraph
  "Creation timestamp"
  createdAt: Int!

  # schema: Schema!   # TODO Beta - not sure how this will work yet

  #### From staking contract ####
  "Total stake of all curators"
  totalCurationStake: BigInt!
  "Total stake of all indexers"
  totalIndexingStake: BigInt!
  "Total curation shares on this subgraph"
  totalCurationShares: BigInt!
  "Curators of this subgraph"
  curatorInfo: [CuratorInfo!] @derivedFrom(field: "subgraphID")
  "Indexers of this subgraph"
  indexerInfo: [IndexerInfo!] @derivedFrom(field: "subgraphID")
  "Bonding curve reserve ratio"
  reserveRatio: BigInt
}

type Indexer @entity {
  "Eth address"
  id: ID!
  "Service registry URL bytes"
  urlBytes: Bytes
  "Service registry URL string"
  urlString: String
  "Array of subgraphs the indexer is indexing"
  indexing: [IndexerInfo!] @derivedFrom(field: "user")
}

type IndexerInfo @entity {
  "Eth address + subgraph ID"
  id: ID!
  "Eth address"
  user: Indexer!
  "IPFS hash of subgraph files"
  subgraphID: SubgraphVersion!
  "Number of tokens the indexer has staked"
  tokensStaked: BigInt! # If this is 0, it means they have logged out
  # By knowing the thawing time, we can derive the time they can withdraw
  "Time logout has started for thawing"
  logoutStartTime: Int!
  # feesAccrued: BigInt # not clear how this will work yet, in the smart contract
  "Amount of tokens locked on this subgraph for this indexer"
  lockedTokens: BigInt!
}

type Curator @entity {
  "Eth address"
  id: ID!
  "Array of subgraphs the curator is curating"
  curating: [CuratorInfo!] @derivedFrom(field: "user")
}

type CuratorInfo @entity {
  "Eth address + subgraph ID"
  id: ID!
  "Eth address"
  user: Curator!
  "IPFS hash of subgraph files"
  subgraphID: SubgraphVersion!
  "Cumulative number of tokens the curator has staked"
  tokensStaked: BigInt!
  "Cumulative number of tokens the curator has unstaked. Not equivalent to tokensStaked. tokensStaked - tokensUnstaked = curating profit"
  tokensUnstaked: BigInt!
  "Number of shares the curator has"
  shares: BigInt!
}

type Account @entity {
  #### From GNS.sol ####
  "Eth address"
  id: ID!
  "IPFS hash with account metadata details"
  metadataHash: Bytes

  #### From GraphToken.sol ####
  "Graph token balance"
  balance: BigInt!
  # "Might add this"
  # approvals: [Bytes!]!
  # "Might add this"
  # allowances: [BigInt!]!

  #### From Staking.sol ####
  "All subgraphs this account curates"
  curating: Curator
  "All subgraphs this accoutn indexes"
  indexing: Indexer
}

# TODO - expose all Staking and other values here. Rename this GraphNetwork
type GraphToken @entity {
  "Set to 1"
  id: ID!
  "Total graph tokens"
  total: BigInt!
}

# might have to add specifics here of each type, but i think i can probably
# actually pass on that. this info might be enough
type Transactions @entity {
  "Tx hash"
  id: ID! # tx hash (plus log index)
  "Block timestamp"
  timestamp: Int!
  "Block number"
  block: Int!
  "Transaction type"
  type: TransactionType!
}

# others to probably add GNS - transfer GNS ownership, delete subgraph, account metadata and subgraph metadata changed
# Staking - curatorBeginLogout, Disputes (not included yet), distribute channel fees
enum TransactionType {
  CurateStake
  CurateUnstake
  IndexingStake
  IndexingUnstake
  RegisterGNS
  UpdateGNS
  DeploySubgraphToGNS
}

#### Not in use for alpha ####

#type Dispute @entity {
#    id: ID! # dispute ID
#    subgraphID: Bytes!
#    indexingNode: Bytes!
#    fisherman: Bytes!
#    attestation: Bytes!
#    status: DisputeStatus!
#}
#
#enum DisputeStatus {
#    Created,
#    Accepted,
#    Rejected
#}
